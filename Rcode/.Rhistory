gamma
?gamma
return(KL)
source('~/Documents/git/ash/Rcode/ash.R')
setwd("~/Documents/git/ash/Rcode/")
set.seed(32327)
## load Poisson_binomial and ash functions
source("../Rcode/ash.R")
library("qvalue")
#simulate n beta-hat values, nnull under the null
#with altmean and altsd being the mean and sd of beta under the alternative
simdata=function(n, nnull, altmean, altsd, betasd){
null = c(rep(1,nnull),rep(0,n-nnull))
beta = c(rep(0,nnull),rnorm(n-nnull,altmean,altsd))
betahat = rnorm(n,beta,betasd)
return(list(null=null,beta=beta,betahat=betahat,betasd=betasd))
}
ss = simdata(10000,8000,0,2,1)
beta.ash=ash(ss$betahat,ss$betasd)
beta.ash.auto = ash(ss$betahat, ss$betasd,auto=TRUE)
beta.ash.vb.uniform = ash(ss$betahat, ss$betasd,auto=TRUE, VB=TRUE, prior="uniform")
warnings()
diriKL = function(p,q){
p.sum = sum(p)
q.sum = sum(q)
k = length(q)
KL = lgamma(q.sum)-lgamma(p.sum)+sum((q-p)*(digamma(q)-digamma(rep(q.sum,k))))+sum(lgamma(p))-lgamma(q)
return(KL)
}
diriKL(c(1,1),c(1,1))
diriKL(c(1,1),c(1,1))
diriKL = function(p,q){
p.sum = sum(p)
q.sum = sum(q)
k = length(q)
KL = lgamma(q.sum)-lgamma(p.sum)+sum((q-p)*(digamma(q)-digamma(rep(q.sum,k))))+sum(lgamma(p)-lgamma(q))
return(KL)
}
diriKL(c(1,1),c(1,1))
beta.ash.vb.uniform = ash(ss$betahat, ss$betasd,auto=TRUE, VB=TRUE, prior="uniform")
beta.ash.vb.uniform = ash(ss$betahat, ss$betasd,auto=TRUE, VB=TRUE, prior="uniform")
course.repodir <- scan("../../../../.course.repodir.txt", what=character())
setwd("~/git/stat45800)
setwd("~/git/stat45800")
setwd("~/git/stat45800")
setwd("~/Documents/git/stat45800")
course.repodir <- scan(".course.repodir.txt", what=character())
ash.repodir = scan(".ash.repodir.txt", what = character())
setwd("~/Documents/git/stat45800")
course.repodir <- scan(".course.repodir.txt", what=character())
ash.repodir = scan(".ash.repodir.txt", what = character())
## load functions
source(file.path(course.repodir, "/code/Rcode/PoissonBinomial.funcs.R"))
source(file.path(course.repodir, "/code/Rcode/cyclespin.R"))
source(file.path(course.repodir, "/code/Rcode/PoissonBinomial.smooth.R"))
source(file.path(course.repodir, "/code/Rcode/deltamethod.R"))
source(file.path(ash.repodir, "/Rcode/ash.R"))
## get an example data!
pheno_path = paste0(course.repodir, "/data/DNase/DNase.17.570.txt")
geno_path = paste0(course.repodir, "/data/DNase/chr17.570.geno")
# most strongly associated SNP
geno_IX = 11
# read total number of reads for each individual
total_reads = scan(file = paste0(course.repodir,"/data/DNase/total_num_reads.txt"))
#> length(total_reads)
phenoT = read.table(pheno_path, as.is = TRUE)
phenoD = as.matrix(phenoT*total_reads*2)
genoD = as.numeric(read.table(geno_path, as.is = TRUE)[geno_IX,4:73])
res.est = cyclespin.smooth(phenoD,g=t(genoD), minobs=2,pseudocounts=0.5,center=TRUE,all=FALSE, forcebin=FALSE, usePointMass = TRUE, fast.approx=TRUE, read.depth = total_reads, prior="uniform")
res.est.PB = PB.smooth(phenoD,g=t(genoD), minobs=2,pseudocounts=0.5,center=TRUE,all=FALSE, forcebin=FALSE, usePointMass = TRUE, fast.approx=TRUE, read.depth = total_reads, prior="uniform")
par(mfrow=c(2,1))
fra = 3
beta_l =  res.est$effect.mean - fra*sqrt(res.est$effect.var)
beta_r = res.est$effect.mean + fra*sqrt(res.est$effect.var)
beta_dataS = res.est$effect.mean
ymin_beta = min(beta_l) - 0.0000000001
ymax_beta = max(beta_r) + 0.0000000001
wh_l = which(beta_l > 0)
wh_r = which(beta_r < 0)
high_wh = sort(unique(union(wh_l, wh_r)))
xval = 1:1024
xmin = min(xval)
xmax = max(xval)
col_posi = xval[high_wh]
par(mar = c(2,4,2,0))
plot(1,1,type="n", xlab = "position", ylab = "Effect size",ylim=c(ymin_beta, ymax_beta),xlim =c(xmin, xmax), main ="With cyclespin", axes=FALSE)
axis(2)
if(length(col_posi) > 0){
for(j in 1:length(col_posi)){
polygon(c(col_posi[j]-0.5, col_posi[j]-0.5, col_posi[j]+0.5, col_posi[j]+0.5), c(ymin_beta-2, ymax_beta+2, ymax_beta+2, ymin_beta-2), col ="pink", border = NA)
}
}
#abline(v = SNPposi, col = "dark green", lwd = 2)
abline(h = 0, col = "red")
points(xval, beta_dataS, col = "blue", type="l")
points(xval, beta_l, col = "skyblue", type="l")
points(xval, beta_r, col = "skyblue", type="l")
box()
fra = 3
beta_l =  res.est.PB$effect.mean - fra*sqrt(res.est.PB$effect.var)
beta_r = res.est.PB$effect.mean + fra*sqrt(res.est.PB$effect.var)
beta_dataS = res.est.PB$effect.mean
ymin_beta = min(beta_l) - 0.0000000001
ymax_beta = max(beta_r) + 0.0000000001
wh_l = which(beta_l > 0)
wh_r = which(beta_r < 0)
high_wh = sort(unique(union(wh_l, wh_r)))
xval = 1:1024
xmin = min(xval)
xmax = max(xval)
col_posi = xval[high_wh]
par(mar = c(2,4,2,0))
plot(1,1,type="n", xlab = "position", ylab = "Effect size",ylim=c(ymin_beta, ymax_beta),xlim =c(xmin, xmax), main ="Without cyclespin", axes=FALSE)
axis(2)
if(length(col_posi) > 0){
for(j in 1:length(col_posi)){
polygon(c(col_posi[j]-0.5, col_posi[j]-0.5, col_posi[j]+0.5, col_posi[j]+0.5), c(ymin_beta-2, ymax_beta+2, ymax_beta+2, ymin_beta-2), col ="pink", border = NA)
}
}
#abline(v = SNPposi, col = "dark green", lwd = 2)
abline(h = 0, col = "red")
points(xval, beta_dataS, col = "blue", type="l")
points(xval, beta_l, col = "skyblue", type="l")
points(xval, beta_r, col = "skyblue", type="l")
box()
par(mar = c(2,4,2,0))
plot(1,1,type="n", xlab = "position", ylab = "Effect size",ylim=c(ymin_beta, ymax_beta),xlim =c(xmin, xmax), main ="With cyclespin", axes=FALSE)
axis(2)
if(length(col_posi) > 0){
for(j in 1:length(col_posi)){
polygon(c(col_posi[j]-0.5, col_posi[j]-0.5, col_posi[j]+0.5, col_posi[j]+0.5), c(ymin_beta-2, ymax_beta+2, ymax_beta+2, ymin_beta-2), col ="pink", border = NA)
}
}
#abline(v = SNPposi, col = "dark green", lwd = 2)
res.est.null = cyclespin.smooth(phenoD,g=t(genoD), minobs=2,pseudocounts=0.5,center=TRUE,all=FALSE, forcebin=FALSE, usePointMass = TRUE, fast.approx=TRUE, read.depth = total_reads, prior=NULL)
plot_effect = function(res,fra=3){
beta_l =  res$effect.mean - fra*sqrt(res$effect.var)
beta_r = res$effect.mean + fra*sqrt(res$effect.var)
beta_dataS = res$effect.mean
ymin_beta = min(beta_l) - 0.0000000001
ymax_beta = max(beta_r) + 0.0000000001
wh_l = which(beta_l > 0)
wh_r = which(beta_r < 0)
high_wh = sort(unique(union(wh_l, wh_r)))
xval = 1:1024
xmin = min(xval)
xmax = max(xval)
col_posi = xval[high_wh]
par(mar = c(2,4,2,0))
plot(1,1,type="n", xlab = "position", ylab = "Effect size",ylim=c(ymin_beta, ymax_beta),xlim =c(xmin, xmax), main ="With cyclespin", axes=FALSE)
axis(2)
if(length(col_posi) > 0){
for(j in 1:length(col_posi)){
polygon(c(col_posi[j]-0.5, col_posi[j]-0.5, col_posi[j]+0.5, col_posi[j]+0.5), c(ymin_beta-2, ymax_beta+2, ymax_beta+2, ymin_beta-2), col ="pink", border = NA)
}
}
#abline(v = SNPposi, col = "dark green", lwd = 2)
abline(h = 0, col = "red")
points(xval, beta_dataS, col = "blue", type="l")
points(xval, beta_l, col = "skyblue", type="l")
points(xval, beta_r, col = "skyblue", type="l")
box()
}
plot_effect(res.est)
fra = 3
plot_effect(res.est)
plot_effect(res.est.PB)
plot_effect = function(res,fra=3,...){
beta_l =  res$effect.mean - fra*sqrt(res$effect.var)
beta_r = res$effect.mean + fra*sqrt(res$effect.var)
beta_dataS = res$effect.mean
ymin_beta = min(beta_l) - 0.0000000001
ymax_beta = max(beta_r) + 0.0000000001
wh_l = which(beta_l > 0)
wh_r = which(beta_r < 0)
high_wh = sort(unique(union(wh_l, wh_r)))
xval = 1:1024
xmin = min(xval)
xmax = max(xval)
col_posi = xval[high_wh]
par(mar = c(2,4,2,0))
plot(1,1,type="n", xlab = "position", ylab = "Effect size",ylim=c(ymin_beta, ymax_beta),xlim =c(xmin, xmax), axes=FALSE,...)
axis(2)
if(length(col_posi) > 0){
for(j in 1:length(col_posi)){
polygon(c(col_posi[j]-0.5, col_posi[j]-0.5, col_posi[j]+0.5, col_posi[j]+0.5), c(ymin_beta-2, ymax_beta+2, ymax_beta+2, ymin_beta-2), col ="pink", border = NA)
}
}
#abline(v = SNPposi, col = "dark green", lwd = 2)
abline(h = 0, col = "red")
points(xval, beta_dataS, col = "blue", type="l")
points(xval, beta_l, col = "skyblue", type="l")
points(xval, beta_r, col = "skyblue", type="l")
box()
}
plot_effect(res.est,main="with cyclespin")
plot_effect(res.est.PB,main="without cyclespin")
plot_effect(res.est.null,main="with cyclespin")
res.est.null = cyclespin.smooth(phenoD,g=t(genoD), minobs=2,pseudocounts=0.5,center=TRUE,all=FALSE, forcebin=FALSE, usePointMass = TRUE, fast.approx=TRUE, read.depth = total_reads, prior=NULL)
plot_effect(res.est,main="with cyclespin, uniform prior")
plot_effect(res.est.null,main="with cyclespin, null prior")
par(mfrow=c(2,1))
plot_effect(res.est,main="with cyclespin, uniform prior")
plot_effect(res.est.null,main="with cyclespin, null prior")
genoD
gperm = sample(genoD)
gperm = sample(genoD)
res.est.perm = cyclespin.smooth(phenoD,g=t(gperm), minobs=2,pseudocounts=0.5,center=TRUE,all=FALSE, forcebin=FALSE, usePointMass = TRUE, fast.approx=TRUE, read.depth = total_reads, prior="uniform")
res.est.perm.null = cyclespin.smooth(phenoD,g=t(gperm), minobs=2,pseudocounts=0.5,center=TRUE,all=FALSE, forcebin=FALSE, usePointMass = TRUE, fast.approx=TRUE, read.depth = total_reads, prior=NULL)
par(mfrow=c(2,1))
plot_effect(res.est.perm,main="permuted data, cyclespin, uniform prior")
plot_effect(res.est.perm.null,main="permuted data, cyclespin, null prior")
res.est.perm.null
names(res.est.perm.null)
res.est.perm.null$effect.mean
ash
beta.ash.pm = ash(ss$betahat, ss$betasd, auto=TRUE, usePointMass=TRUE)
beta.ash.pm$fitted.f
pnorm(0,0,0,lower.tail=TRUE)
pnorm(1,0,0,lower.tail=TRUE)
pnorm(-0.002,0,0,lower.tail=TRUE)
pnorm(-0.002,0,0,lower.tail=FALSE)
pnorm(-0.002,0,0,lower.tail=FALSE)
?pnorm
epsilon
?epsilon
??epsilon
??machineepsilon
??machine.epsilon
??small
??zero
pnormmix
source('~/Documents/git/ash/Rcode/ash.R', echo=TRUE)
source('~/Documents/git/ash/Rcode/ash.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/Documents/git/ash/Rcode/ash.R', echo=TRUE)
source('~/Documents/git/ash/Rcode/ash.R')
beta.ash.pm = ash(ss$betahat, ss$betasd, auto=TRUE, usePointMass=TRUE)
plot(beta.ash.pm$ZeroProb)
xx=(beta.ash.pm$ZeroProb)
xx
pi.fit$pi
source('~/Documents/git/ash/Rcode/ash.R')
beta.ash.pm = ash(ss$betahat, ss$betasd, auto=TRUE, usePointMass=TRUE)
source('~/Documents/git/ash/Rcode/ash.R')
ZeroProb = colSums(post$pi[sigmaavec==0,,drop=FALSE])
source('~/Documents/git/ash/Rcode/ash.R')
beta.ash.pm = ash(ss$betahat, ss$betasd, auto=TRUE, usePointMass=TRUE)
beta.ash.pm$fitted.f
source('~/Documents/git/ash/Rcode/ash.R')
the false sign rate by a factor of 2. Therefore, to be conservative, we might prefer to analyze the data allowing for the point mass, or, if analyzed without a point mass, multiply estimated false sign rates by 2.
