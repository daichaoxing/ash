for(i in 1:1000){x[,i] = rnorm(10)}
dim(x)
t(y) %*% y
d1 = rep(0,1000)
lm(y[,1] ~ x[,1])
lm(y[,1] ~ x[,1])$res
lm(y[,1] ~ x[,1])$res %*% lm(y[,2] ~ x[,1]$res
)
lm(y[,1] ~ x[,1])$res %*% lm(y[,2] ~ x[,1])$res
for(i in 1:1000){res = cbind(lm(y[,1]~x[,i])$res,lm(y[,2] ~x[,i])$res);
rss1 = t(res) %*% res
d[i] = det(rss1)
}
rss
rss0
d1 = d
for(i in 1:1000){res = cbind(lm(y[,1]~x[,i])$res,lm(y[,2] ~x[,i])$res); rss1=t(res) %*% res; d[i] = det(rss1); d1 = det(0.5*rss0 + 0.5*rss1)}
rss0 = t(y) %*% y
for(i in 1:1000){res = cbind(lm(y[,1]~x[,i])$res,lm(y[,2] ~x[,i])$res); rss1=t(res) %*% res; d[i] = det(rss1); d1 = det(0.5*rss0 + 0.5*rss1)}
plotd,d1
plot(d,d1)
for(i in 1:1000){res = cbind(lm(y[,1]~x[,i])$res,lm(y[,2] ~x[,i])$res); rss1=t(res) %*% res; d[i] = det(rss1); d1[i] = det(0.5*rss0 + 0.5*rss1)}
plot(d,d1)
for(i in 1:1000){res = cbind(lm(y[,1]~x[,i])$res,lm(y[,2] ~x[,i])$res); rss1=t(res) %*% res; d[i] = det(rss1); d1[i] = det(0.9*rss0 + 0.1*rss1)}
plot(d,d1)
for(i in 1:1000){res = cbind(lm(y[,1]~x[,i])$res,lm(y[,2] ~x[,i])$res); rss1=t(res) %*% res; d[i] = det(rss1); d1[i] = det(0.99*rss0 + 0.01*rss1)}
plot(d,d1)
X = rgamma(1000,1,1/7)
X = rgamma(7000,1,1/7)
?rdirich
?dirichlet
help.start()
load("compositions")
install.package("compositions")
install.packages("compositions")
load("compositions")
install.packages("compositions")
load("compositions")
exp(1)
exp(10)
log10(exp(10))
log10(exp(15))
-exp(1) * p * log(p)
p = 1e-8
-exp(1) * p * log(p)
(-exp(1) * p * log(p))^-1
log10((-exp(1) * p * log(p))^-1)
p = 3e-8
log10((-exp(1) * p * log(p))^-1)
p = 5e-8
log10((-exp(1) * p * log(p))^-1)
hist(rpois(1000,3))
dpois(1:10,3)
dpois(0:10,3)
qpois(0:10,3)
ppois(0:10,3)
?cor
?rank
rank(c(1,2,1,3,1,2))
x = rbinom(100,2,0.2)
y = rnom(100)
y = rnorm(100)
y = rbinom(100,1,0.4)
glm(y~x,family=binomial)
summary(glm(y~x,family=binomial))
summary(glm(y~x,family=binomial))$f
summary(glm(y~x,family=binomial))$fstat
names(summary(glm(y~x,family=binomial)))
(summary(glm(y~x,family=binomial))$deviance
)
1000*1.05^112
1000*1.05^100
?manova
?summary.manova
library("haarfisz")
library(haarfisz)
q()
258/150
hdf5
z = rnorm(2,1)
z = rnorm(1000,mean=2,1)
p = pnorm(z)
hist(p)
hist(1-p)
z = rnorm(1000,mean=1,1)
p = pnorm(z)
hist(1-p)
z = rnorm(1000,mean=.5,1)
p = pnorm(z)
hist(1-p)
install.packages("knitr")
s = "btpsffsttbppsffppsffstbbpstbtpfstfbtbpstfspbbtsffsfptbtsppftpsbbst
btpsfpbsftpbp
btpsfpbtpsbftpfbtsbfsptbspfstfbtspbtffpsbpsfttbpspftfbbsptbptsfftpbfssppsffstbbpstbttsfbftpfbss
"
length(s)
s = split(s,"")
s
?split
s = s$1
s = s[[1]]
s
?paste
?strsplit
ss = strsplit(s, split="")
ss
sum(ss=="b")
sum(ss[[1]]=="b")
hist(ss[[1]])
barchart(ss[[1]])
?hist
?barchart
barplot(ss[[1]])
?barplot
table(ss[[1]])
ss[[1]]
tt = ss[[1]]
tt = tt[-1]
tt
u = cbind(tt,ss[[1]][-176])
u
u = cbind(tt,ss[[1]][-177])
u
u = cbind(ss[[1]][-177],tt)
u
table(u[,2][u[,1]=="b"])
table(u[,2][u[,1]=="f"])
table(u[,2][u[,1]=="t"])
table(u[,2][u[,1]=="p"])
table(u[,2][u[,1]=="s"])
?crosstab
?table
table(u[,1],u[,2])
?ragged
??ragged
install.packages("wavelets")
?wavelets
library(wavelets)
?wavelets
?dwt
dwt
J = 2^10
npeak = 5
peakcenters = sample(1:J,5,replace=F)
peakwidth = rep(50,npeak)
mu = 100*(rowSums(matDens(1:J,peakcenters,peakwidth)) + 0.002)
x = rpois(J,mu)
plot(mu,type="l",xlab="base",ylab="intensity",ylim=c(0,max(mu)),main="Poisson intensity")
abline(v=peakcenters,col="red")
plot(x, main="Simulated Poisson data")
set.seed(100)
library("mixfdr") # I use the function matDens to compute mixture density
J = 2^10
npeak = 5
peakcenters = sample(1:J,5,replace=F)
peakwidth = rep(50,npeak)
mu = 100*(rowSums(matDens(1:J,peakcenters,peakwidth)) + 0.002)
x = rpois(J,mu)
plot(mu,type="l",xlab="base",ylab="intensity",ylim=c(0,max(mu)),main="Poisson intensity")
abline(v=peakcenters,col="red")
plot(x, main="Simulated Poisson data")
dwt(x)
dwt(x,fast=FALSE)
system.time(dwt(x))
dim(x)
length(x)
J = 2^20
npeak = 5
peakcenters = sample(1:J,5,replace=F)
peakwidth = rep(50,npeak)
mu = 100*(rowSums(matDens(1:J,peakcenters,peakwidth)) + 0.002)
x = rpois(J,mu)
plot(mu,type="l",xlab="base",ylab="intensity",ylim=c(0,max(mu)),main="Poisson intensity")
abline(v=peakcenters,col="red")
plot(x, main="Simulated Poisson data")
dim(x)
length(x)
system.time(dwt(x))
source("~/Documents/teaching/Workshop2013/stat45800/code/Rcode/PoissonBinomial.funcs.R")
haar.aggregate
system.time(haar.aggregate(x))
system.time(dwt(x))
dwt
J = 2^20
J = 2^10
bintest.haar
bintest
x=0
p=10000
n=1000
niter=100
beta.sd=1 #effect size
sdz = rep(0,niter)
sdzminusb = rep(0,niter)
sdz0= sdz
niter=1
x = matrix(rbinom(n*p,2,0.2),ncol=p)
x = scale(x,scale=FALSE) #center
xx = apply(x,2,sd)
x = t(t(x)/xx) # standardize by column root-mean-square
x[1,] %*% x[,1]
x[1,] * x[,1]
sum(x[1,] * x[,1])
sum(x[1,] * x[1,])
sum(x[,1] * x[,1])
sqrt(mean(y.lm$betahat^2))
beta = rnorm(p,mean=0,sd=beta.sd/sqrt(p))
#beta[1:10]=c(-1,-1,-1,-1,-1,1,1,1,1,1)
Ey = x %*% beta
E = rnorm(n,0,1) #error term
#sd(Ey) #check it should be close to beta.sd
y = Ey + E
y.lm = linreg(y,x)
y.ash = ash(y.lm$betahat,y.lm$sebetahat)
y.ash.pm = ash(y.lm$betahat,y.lm$sebetahat,usePointMass=TRUE)
linreg = function(y,x){
SX2 = colSums(x*x) #a p vector of sums of squares
betahat = as.vector(SX2^{-1} * (t(x) %*% y)) # a p vector
resid = as.vector(y) - t(t(x)*betahat)  # residuals, n by g
sigmahat = sqrt(colMeans(resid*resid)) # g vector, estimated residual variances
sebetahat = SX2^{-0.5} * sigmahat
return(list(betahat=betahat,sebetahat=sebetahat))
}
require("ashr")
y.lm = linreg(y,x)
y.ash = ash(y.lm$betahat,y.lm$sebetahat)
y.ash.pm = ash(y.lm$betahat,y.lm$sebetahat,usePointMass=TRUE)
plot(y.ash$PosteriorMean,beta)
plot(y.lm$betahat,beta)
sqrt(mean((y.lm$betahat-beta)^2)) #root mean square error of raw beta-hat
sqrt(mean((y.ash$PosteriorMean-beta)^2))
sqrt(mean(beta^2))
sqrt(mean(y.lm$betahat^2))
sqrt(1/1000)
mean(y.lm$betahat^2)
n
var(y)
var(Ey)
var(E)
sqrt(mean((y.lm$betahat-beta)^2)) #root mean square error of raw beta-hat
sqrt(var(y)/n)
x = t(t(x)/xx) # standardize by column root-mean-square
sd(x[,1])
sum(x[,1]^2)
x = scale(x,scale=FALSE) #center
xx = apply(x,2,sd)
x = t(t(x)/xx) # standardize by column root-mean-square
sum(x[,1]^2)
mean(x[,1]^2)
n=100
nrep=10000
rho=0.2
X1 = matrix(rnorm(n*nrep),ncol=nrep)
X2 = 0.2*X1 + 0.8*matrix(rnorm(n*nrep),ncol=nrep)
cor(X1[,1],X2[,1])
cor(X1[,2],X2[,2])
cor(X1[,3],X2[,3])
cor(X1[,4],X2[,4])
X1 = matrix(rnorm(n*nrep),ncol=nrep)
X2 = 0.2*X1 + 0.8*matrix(rnorm(n*nrep),ncol=nrep)
Y = X1+X2+ matrix(rnorm(n*nrep),ncol=nrep)
Z1 = t(X1) %*% Y
Z2 = t(X2) %*% Y
dim(Z1)
Z1 = apply(X1*Y, 1, sum)
length(Z1)
Z2 = apply(X2*Y,2,sum)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
cor(Z1,Z2)
X1 = matrix(rnorm(n*nrep),ncol=nrep)
X2 = 0.2*X1 + 0.8*matrix(rnorm(n*nrep),ncol=nrep)
Y = X1+X2+ 100*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
cor(Z1,Z2)
n=1000
nrep=10000
rho=0.2
X1 = matrix(rnorm(n*nrep),ncol=nrep)
X2 = 0.2*X1 + 0.8*matrix(rnorm(n*nrep),ncol=nrep)
Y = X1+X2+ 100*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
cor(Z1,Z2)
n=1000
nrep=10000
rho=0.2
X1 = matrix(rnorm(n*nrep),ncol=nrep)
X2 = 0.2*X1 + 0.8*matrix(rnorm(n*nrep),ncol=nrep)
Y = X1+X2+ 100*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
cor(Z1,Z2)
n=1000
nrep=10000
rho=0.4
X1 = matrix(rnorm(n*nrep),ncol=nrep)
X2 = 0.2*X1 + 0.8*matrix(rnorm(n*nrep),ncol=nrep)
Y = X1+X2+ 100*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
X1 = matrix(rnorm(n*nrep),ncol=nrep)
X2 = sqrt(rho)*X1 + sqrt(1-rho)*matrix(rnorm(n*nrep),ncol=nrep)
cor(X1[,1],X2[,1])
rho
cor(X1[,1],X2[,3])
cor(X1[,3],X2[,3])
cor(X1[,4],X2[,4])
cor(X1[,5],X2[,5])
sqrt(rho)
rho=0.2
X1 = matrix(rnorm(n*nrep),ncol=nrep)
X2 = (rho*X1 + (1-rho)*matrix(rnorm(n*nrep),ncol=nrep))/(rho^2 + (1-rho)^2)
apply(X2,2,sd)
apply(X1,2,sd)
apply(X2,2,var)
X2 = (rho*X1 + (1-rho)*matrix(rnorm(n*nrep),ncol=nrep))/sqrt(rho^2 + (1-rho)^2)
apply(X2,2,var)
apply(X2,2,sd)
Y = X1+X2+ 100*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
cor(Z1,Z2)
Y = X1+X2+ matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
cor(Z1,Z2)
Y = X1+X2+ 1000*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
cor(Z1,Z2)
apply(X1*X2,2,sum)
apply(X1*X2,2,sum)/1000
hist(apply(X1*X2,2,sum)/1000)
mean(apply(X1*X2,2,sum)/1000)
cor(Z1,X2)
cor(Z1,Z2)
apply(X1*X2,2,mean) # compute empirical correlation
mean(apply(X1*X2,2,mean)) # compute empirical (mean) correlation
cor(Z1,Z2)
lambda=1000
Y = X1+X2+ lambda*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
cor(Z1,Z2)
mean(apply(X1*X2,2,mean)) # compute empirical (mean) correlation
lambda=10
Y = X1+X2+ lambda*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
cor(Z1,Z2)
mean(apply(X1*X2,2,mean)) # compute empirical (mean) correlation
lambda=1
Y = X1+X2+ lambda*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
cor(Z1,Z2)
mean(apply(X1*X2,2,mean)) # compute empirical (mean) correlation
lambda=seq(1,10,100,1000)
for(i in 1:length(lambda)){
Y = X1+X2+ lambda[i]*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
print(cor(Z1,Z2),mean(apply(X1*X2,2,mean))) # compute empirical (mean) correlation of Z1,Z2 and X1,X2
n=1000
nrep=10000
rho=0.2
#set up columns of X1 and X2 to have correlation rho, variance 1
X1 = matrix(rnorm(n*nrep),ncol=nrep)
X2 = (rho*X1 + (1-rho)*matrix(rnorm(n*nrep),ncol=nrep))/sqrt(rho^2 + (1-rho)^2)
#actually doesn't quite work.. need to compute this correlation
lambda=c(1,10,100,1000)
for(i in 1:length(lambda)){
Y = X1+X2+ lambda[i]*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
print(cor(Z1,Z2),mean(apply(X1*X2,2,mean))) # compute empirical (mean) correlation of Z1,Z2 and X1,X2
}
n=1000
}
n=1000
nrep=10000
rho=0.2
#set up columns of X1 and X2 to have correlation rho, variance 1
X1 = matrix(rnorm(n*nrep),ncol=nrep)
X2 = (rho*X1 + (1-rho)*matrix(rnorm(n*nrep),ncol=nrep))/sqrt(rho^2 + (1-rho)^2)
#actually doesn't quite work.. need to compute this correlation
lambda=c(1,10,100,1000)
for(i in 1:length(lambda)){
Y = X1+X2+ lambda[i]*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
print(cor(Z1,Z2),mean(apply(X1*X2,2,mean))) # compute empirical (mean) correlation of Z1,Z2 and X1,X2
}
```
i=1
Y = X1+X2+ lambda[i]*matrix(rnorm(n*nrep),ncol=nrep)
Z1 = apply(X1*Y, 2, sum)
Z2 = apply(X2*Y,2,sum)
print(cor(Z1,Z2),mean(apply(X1*X2,2,mean))) # compute empirical (mean) correlation of Z1,Z2 and X1,X2
cor(Z1,Z2)
Y=matrix(rnorm(n*nrep),ncol=nrep)
X=matrix(rnorm(n*nrep),ncol=nrep)
mean(apply(Y*X,2,mean))
bhat = apply(Y*X,2,mean)
sd(bhat)
1/sqrt(1000)
sample_in
sample_int
?sampleint
?sample./int
?sample.int
fun(1:3, 1:4)
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericVector xa(a);
Rcpp::NumericVector xb(b);
int n_xa = xa.size(), n_xb = xb.size();
Rcpp::NumericVector xab(n_xa + n_xb - 1);
for (int i = 0; i < n_xa; i++)
for (int j = 0; j < n_xb; j++)
xab[i + j] += xa[i] * xb[j];
return xab;
'
fun <- cxxfunction(signature(a = "numeric", b = "numeric"),src, plugin = "Rcpp")
fun(1:3, 1:4)
View(P)
load("debug_logLR_inf.Robj")
pwd
system("pwd")
source('~/.active-rstudio-document', echo=TRUE)
load("../paper/Rcode/sim1_out.RData") #load simulation results
setwd("~/Dropbox/Documents/git/ash/talks")
load("../paper/Rcode/sim1_out.RData") #load simulation results
load("../paper/Rcode/sim1.RData")
plot_pi0(list(simres1a))
source("../paper/Rcode/plot_pi0.R")
plot_pi0(list(simres1a))
get_pi0.ash
get_pi0(z.ash)
get_pi0.ash(z.ash)
library("ashr")
get_pi0.ash(z.ash)
ashr::get_pi0
get_pi0(z.ash)
plot_FDReg_hist(pval)
load("../scratchwork/Smemo_qbinom_zdat.RData")
# two-sided test
ttest.pval = function(t, df) {
pval = pt(t, df = df, lower.tail = T)
pval = 2 * ifelse(pval < 0.5, pval, 1 - pval)
return(pval)
}
tscore = zdat[3, ]/zdat[4, ]
pval = ttest.pval(tscore, df = 2)
qval = qvalue(pval)
highxp = xx>1000 # select high expressed genes
library(qvalue)
x = read.table(paste0("../../stat45800/data/nobrega/expression/counts.txt"), header = TRUE)
xx = rowSums(x[,2:5])
x = x[xx>0,]
xx = xx[xx>0]
highxp = xx>1000 # select high expressed genes
pval.high = pval[highxp]
qval.high = qvalue(pval.high)
qval.high
min(qval.high)
min(qval.high$qval)
zdat.ash$lfsr
%sfd
#sdf
zdat.ash
zdat
load("../scratchwork/Smemo_qbinom_zdat.RData")
zdat.ash = ash(zdat[3,],zdat[4,],df=2,method="fdr",mixcompdist="halfuniform")
hist(zdat[3,],main="Raw effect size estimates",xlab="betahat",xlim=c(-2,2),prob=T,ylim=c(0,3))
t=seq(-2,2,length=201)
lines(density(zdat.ash,t), col=2, lwd=2)
plot(zdat[3,],zdat.ash$PosteriorMean,main="Estimates vs Shrunken estimates",xlab="betahat",ylab="shrunk betahat",xlim=c(-2,2),ylim=c(-2,2),prob=T)
plot(zdat[3,],zdat.ash$PosteriorMean,main="Estimates vs Shrunken estimates",xlab="betahat",ylab="shrunk betahat",xlim=c(-2,2),ylim=c(-2,2))
warnings()
plot(zdat[3,],zdat.ash$PosteriorMean,main="Estimates vs Shrunken estimates",xlab="betahat",ylab="shrunk betahat",xlim=c(-2,2),ylim=c(-2,2))
zdat[3,]
zdat.ash$Posterior
names(zdat.ash)
zdat.ash$PosteriorMean
zdat.ash$g
zdat.ash$fitted
lines(density(zdat.ash,t), col=2, lwd=2)
density.ash
ashr:::density.ash
??ashr::dens
??ashr::dens.unimix
lines(cdf(zdat.ash,t), col=2, lwd=2)
cdf.as
cdf.ash
plot(cdf(zdat.ash,t), col=2, lwd=2)
plot(cdf.ash(zdat.ash,t), col=2, lwd=2)
zdat.ash$PosteriorMean
ash
zdat.ash$Negative
zdat.ash$Positive
z=rnorm(1000)
zz = ash(z,1,method="fdr",mixcompdist="uniform")
zz$PosteriorMean
install.packages("~/Dropbox/Documents/git/ash/package/ashr.tar.gz",type="source")
library(ashr)
zz = ash(z,1,method="fdr",mixcompdist="uniform")
zz$Posterior
zz$PosteriorMean
zz$fitted
